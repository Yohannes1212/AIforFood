{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "9f8c6206-1c80-4751-964d-9798105ce4e1",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "def plot_confusion_matrix(y_true, y_pred, title=\"Confusion Matrix\"):  \n",
    "    \"\"\"Plots the confusion matrix.\"\"\"  \n",
    "    cm = confusion_matrix(y_true, y_pred)  \n",
    "    plt.figure(figsize=(8, 6))  \n",
    "    sns.heatmap(cm, annot=True, fmt=\"d\", cmap=\"Blues\")  \n",
    "    plt.xlabel('Predicted')  \n",
    "    plt.ylabel('Actual')  \n",
    "    plt.title(title)  \n",
    "    plt.show()  \n",
    "\n",
    "def classify_model(model, features, target, model_name, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    \"\"\"\n",
    "    Performs classification with the given model, with optional LDA and PCA for dimensionality reduction.\n",
    "    \n",
    "    Args:\n",
    "        model: Machine learning model.\n",
    "        features (array-like): Feature matrix.\n",
    "        target (array-like): Target labels.\n",
    "        model_name (str): Name of the model for identification.\n",
    "        pca_components (int, optional): Number of PCA components. If None, PCA is not applied.\n",
    "        lda_components (bool or int, optional): If True, LDA is applied with n_components=num_classes-1.\n",
    "        return_accuracy (bool, optional): Whether to return mean accuracy.\n",
    "        \n",
    "    Returns:\n",
    "        float (optional): Mean accuracy if return_accuracy is True.\n",
    "    \"\"\"\n",
    "    num_classes = len(np.unique(target))\n",
    "    \n",
    "    # Initialize pipeline steps\n",
    "    pipeline_steps = [\n",
    "        ('scaler', StandardScaler())  # Standardize the data\n",
    "    ]\n",
    "    \n",
    "    # Apply LDA if specified\n",
    "    if lda_components:\n",
    "        pipeline_steps.append(('lda', LDA(n_components=num_classes - 1)))\n",
    "    \n",
    "    # Apply PCA if specified\n",
    "    if pca_components:\n",
    "        pipeline_steps.append(('pca', PCA(n_components=pca_components)))\n",
    "    \n",
    "    # Add the model to the pipeline\n",
    "    pipeline_steps.append((model_name, model))\n",
    "    \n",
    "    # Create the pipeline\n",
    "    pipeline = Pipeline(pipeline_steps)\n",
    "    \n",
    "    # Perform cross-validation\n",
    "    cv = StratifiedKFold(n_splits=5, shuffle=True, random_state=42)\n",
    "    cv_scores = cross_val_score(pipeline, features, target, cv=cv, scoring='accuracy', n_jobs=-1)\n",
    "    \n",
    "    print(f\"\\n{model_name.upper()} Classification Results \"\n",
    "          f\"(LDA Components: {lda_components if lda_components else 'None'}, \"\n",
    "          f\"PCA Components: {pca_components if pca_components else 'None'}):\")\n",
    "    print(\"Cross-Validation Scores:\", cv_scores)\n",
    "    print(\"Mean CV Accuracy:\", cv_scores.mean())\n",
    "\n",
    "    # Predict using cross-validation\n",
    "    y_pred = cross_val_predict(pipeline, features, target, cv=cv, n_jobs=-1)\n",
    "    plot_confusion_matrix(target, y_pred, title=f\"{model_name.upper()} Confusion Matrix\")\n",
    "    print(classification_report(target, y_pred))\n",
    "    \n",
    "    if return_accuracy:\n",
    "        return cv_scores.mean()  # Return the mean accuracy if requested\n",
    "\n",
    "def knn(features, target, params, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    model = KNeighborsClassifier(**params)\n",
    "    return classify_model(model, features, target, 'knn', pca_components=pca_components, lda_components=lda_components, return_accuracy=return_accuracy)\n",
    "\n",
    "def svm(features, target, params, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    model = SVC(**params)\n",
    "    return classify_model(model, features, target, 'svm', pca_components=pca_components, lda_components=lda_components, return_accuracy=return_accuracy)\n",
    "\n",
    "def rf(features, target, params, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    \"\"\"Random Forest Classifier.\"\"\"  \n",
    "    model = RandomForestClassifier(**params) \n",
    "    return classify_model(model, features, target, 'rf', pca_components=pca_components, lda_components=lda_components, return_accuracy=return_accuracy)\n",
    "\n",
    "def lr(features, target, params, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    \"\"\"Logistic Regression Classifier.\"\"\"  \n",
    "    model = LogisticRegression(**params)  \n",
    "    return classify_model(model, features, target, 'lr', pca_components=pca_components, lda_components=lda_components, return_accuracy=return_accuracy)\n",
    "\n",
    "def mlp(features, target, params, pca_components=None, lda_components=False, return_accuracy=False):\n",
    "    \"\"\"Multi-Layer Perceptron Classifier.\"\"\"  \n",
    "    model = MLPClassifier(**params)  \n",
    "    return classify_model(model, features, target, 'mlp', pca_components=pca_components, lda_components=lda_components, return_accuracy=return_accuracy)\n",
    "\n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.20"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
